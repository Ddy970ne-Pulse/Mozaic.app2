#!/usr/bin/env python3
"""
TEST COMPLET DES FONCTIONNALIT√âS MOZAIK RH APR√àS IMPL√âMENTATION WEBSOCKET
Test complet des fonctionnalit√©s MOZAIK RH apr√®s impl√©mentation WebSocket et ajout rapide d'absence

OBJECTIF: V√©rifier que toutes les nouvelles fonctionnalit√©s WebSocket et ajout rapide d'absence fonctionnent correctement.
USER ACCOUNT: Admin Diego DACALOR (ddacalor@aaea-gpe.fr / admin123)

TESTS √Ä EFFECTUER:
1. Test WebSocket Connection - wss://hr-multi-saas.preview.emergentagent.com/api/ws/{user_id}
2. Test API Absences (Ajout Rapide) - POST /api/absences
3. Test GET /api/users - v√©rifier champ email non undefined
4. Tests Existants - valider endpoints existants
"""

import requests
import json
import sys
import os
import asyncio
import websockets
import threading
import time
from datetime import datetime, timedelta

# Configuration
BACKEND_URL = "https://hr-multi-saas.preview.emergentagent.com/api"
WEBSOCKET_URL = "wss://hr-multi-saas.preview.emergentagent.com/api/ws"
ADMIN_EMAIL = "ddacalor@aaea-gpe.fr"
ADMIN_PASSWORD = "admin123"

class WebSocketAbsenceTester:
    def __init__(self):
        self.token = None
        self.user_id = None
        self.session = requests.Session()
        self.websocket_messages = []
        self.websocket_connected = False
        self.test_results = {
            "websocket": {"passed": 0, "failed": 0, "details": []},
            "absence_api": {"passed": 0, "failed": 0, "details": []},
            "users_api": {"passed": 0, "failed": 0, "details": []},
            "existing_apis": {"passed": 0, "failed": 0, "details": []}
        }
        
    def log_result(self, phase, test_name, success, message, expected=None, actual=None):
        """Log test result"""
        status = "‚úÖ PASS" if success else "‚ùå FAIL"
        detail = {
            "test": test_name,
            "status": status,
            "message": message
        }
        if expected is not None:
            detail["expected"] = expected
        if actual is not None:
            detail["actual"] = actual
            
        self.test_results[phase]["details"].append(detail)
        if success:
            self.test_results[phase]["passed"] += 1
        else:
            self.test_results[phase]["failed"] += 1
            
        print(f"{status} {test_name}: {message}")
        if expected is not None and actual is not None:
            print(f"    Expected: {expected}")
            print(f"    Actual: {actual}")

    def authenticate(self):
        """Authenticate as admin Diego DACALOR"""
        print(f"\nüîê AUTHENTICATION - Admin Diego DACALOR")
        print("=" * 60)
        
        try:
            response = self.session.post(f"{BACKEND_URL}/auth/login", json={
                "email": ADMIN_EMAIL,
                "password": ADMIN_PASSWORD
            })
            
            if response.status_code == 200:
                data = response.json()
                self.token = data.get("token")
                user = data.get("user", {})
                self.user_id = user.get("id")
                print(f"‚úÖ Login successful: {user.get('name')} ({user.get('email')})")
                print(f"‚úÖ Role: {user.get('role')}")
                print(f"‚úÖ User ID: {self.user_id}")
                print(f"‚úÖ Token obtained: {self.token[:20]}...")
                
                # Set authorization header for all future requests
                self.session.headers.update({"Authorization": f"Bearer {self.token}"})
                return True
            else:
                print(f"‚ùå Login failed: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            print(f"‚ùå Authentication error: {str(e)}")
            return False

    def test_phase1_file_deletion(self):
        """PHASE 1 - SUPPRESSION FICHIERS TEST"""
        print(f"\nüìÅ PHASE 1 - SUPPRESSION FICHIERS TEST")
        print("=" * 60)
        
        # Test 1: V√©rifier que test_workflow.py n'existe plus
        test_workflow_exists = os.path.exists("/app/test_workflow.py") or os.path.exists("/app/backend/test_workflow.py")
        self.log_result("phase1", "test_workflow.py supprim√©", 
                       not test_workflow_exists, 
                       "Fichier test_workflow.py n'existe plus" if not test_workflow_exists else "Fichier test_workflow.py existe encore")
        
        # Test 2: V√©rifier que MonthlyPlanningTest.js n'existe plus
        monthly_test_exists = os.path.exists("/app/frontend/src/MonthlyPlanningTest.js") or os.path.exists("/app/MonthlyPlanningTest.js")
        self.log_result("phase1", "MonthlyPlanningTest.js supprim√©", 
                       not monthly_test_exists, 
                       "Fichier MonthlyPlanningTest.js n'existe plus" if not monthly_test_exists else "Fichier MonthlyPlanningTest.js existe encore")

    def test_phase2_real_analytics(self):
        """PHASE 2 - ANALYTICS R√âELLES"""
        print(f"\nüìä PHASE 2 - ANALYTICS R√âELLES")
        print("=" * 60)
        
        try:
            # Test 1: GET /api/analytics/absence-kpi
            response = self.session.get(f"{BACKEND_URL}/analytics/absence-kpi")
            
            if response.status_code == 200:
                analytics_data = response.json()
                print(f"‚úÖ Analytics endpoint accessible (200)")
                
                # Test 2: V√©rifier que les donn√©es sont r√©elles (pas mock√©es)
                summary = analytics_data.get("summary", {})
                total_absences = summary.get("totalAbsences", 0)
                
                # Les donn√©es mock√©es avaient 1542 absences - v√©rifier que ce n'est plus le cas
                is_real_data = total_absences != 1542 and total_absences > 0
                self.log_result("phase2", "Donn√©es r√©elles retourn√©es", 
                               is_real_data,
                               f"Total absences: {total_absences} (donn√©es r√©elles)" if is_real_data else f"Total absences: {total_absences} (possiblement mock√©es)",
                               "Donn√©es r√©elles (‚â† 1542)", total_absences)
                
                # Test 3: V√©rifier byCategory contient types d'absences r√©els
                by_category = analytics_data.get("byCategory", [])
                has_real_categories = len(by_category) > 0
                category_names = [cat.get("name", "") for cat in by_category] if isinstance(by_category, list) else []
                self.log_result("phase2", "byCategory avec types r√©els", 
                               has_real_categories,
                               f"Categories trouv√©es: {category_names[:5]}" if has_real_categories else "Aucune cat√©gorie trouv√©e")
                
                # Test 4: V√©rifier monthlyTrend calcul√© depuis vraies donn√©es
                monthly_trend = analytics_data.get("monthlyTrend", [])
                has_monthly_trend = len(monthly_trend) > 0
                self.log_result("phase2", "monthlyTrend calcul√©", 
                               has_monthly_trend,
                               f"Tendance mensuelle: {len(monthly_trend)} mois de donn√©es" if has_monthly_trend else "Aucune tendance mensuelle")
                
                # Test 5: V√©rifier departmentBreakdown bas√© sur vrais d√©partements
                department_breakdown = analytics_data.get("departmentBreakdown", [])
                has_departments = len(department_breakdown) > 0
                department_names = [dept.get("department", "") for dept in department_breakdown] if isinstance(department_breakdown, list) else []
                self.log_result("phase2", "departmentBreakdown avec vrais d√©partements", 
                               has_departments,
                               f"D√©partements: {department_names[:5]}" if has_departments else "Aucun d√©partement trouv√©")
                
                print(f"\nüìã D√âTAILS ANALYTICS:")
                print(f"   Total Absences: {total_absences}")
                print(f"   Categories: {category_names[:3]}")
                print(f"   Mois de tendance: {len(monthly_trend)}")
                print(f"   D√©partements: {department_names[:3]}")
                
            else:
                self.log_result("phase2", "Analytics endpoint accessible", 
                               False, f"Erreur {response.status_code}: {response.text}")
                
        except Exception as e:
            self.log_result("phase2", "Analytics endpoint test", 
                           False, f"Exception: {str(e)}")

    def test_phase3_absence_types_db(self):
        """PHASE 3 - ABSENCE TYPES EN BDD"""
        print(f"\nüóÉÔ∏è PHASE 3 - ABSENCE TYPES EN BDD")
        print("=" * 60)
        
        try:
            # Test 1: GET /api/absence-types
            response = self.session.get(f"{BACKEND_URL}/absence-types")
            
            if response.status_code == 200:
                absence_types = response.json()
                print(f"‚úÖ Absence types endpoint accessible (200)")
                
                # Test 2: V√©rifier 22 types d'absence retourn√©s depuis MongoDB
                types_count = len(absence_types)
                expected_count = 22
                has_correct_count = types_count == expected_count
                self.log_result("phase3", "22 types d'absence retourn√©s", 
                               has_correct_count,
                               f"{types_count} types trouv√©s" if has_correct_count else f"Nombre incorrect: {types_count}",
                               expected_count, types_count)
                
                # Test 3: V√©rifier structure correcte (code, name, category, counting_method, etc.)
                if absence_types:
                    first_type = absence_types[0]
                    required_fields = ["code", "name", "category", "counting_method", "requires_validation", "requires_acknowledgment"]
                    has_correct_structure = all(field in first_type for field in required_fields)
                    self.log_result("phase3", "Structure correcte des types", 
                                   has_correct_structure,
                                   f"Champs pr√©sents: {list(first_type.keys())}" if has_correct_structure else f"Champs manquants dans: {list(first_type.keys())}")
                
                # Afficher quelques types pour v√©rification
                print(f"\nüìã TYPES D'ABSENCE TROUV√âS ({types_count}):")
                for i, abs_type in enumerate(absence_types[:5]):  # Afficher les 5 premiers
                    print(f"   {i+1}. {abs_type.get('code')} - {abs_type.get('name')} ({abs_type.get('counting_method')})")
                if types_count > 5:
                    print(f"   ... et {types_count - 5} autres")
                
            else:
                self.log_result("phase3", "Absence types endpoint accessible", 
                               False, f"Erreur {response.status_code}: {response.text}")
                return
                
            # Test 4: GET /api/absence-types/CA
            response_ca = self.session.get(f"{BACKEND_URL}/absence-types/CA")
            
            if response_ca.status_code == 200:
                ca_type = response_ca.json()
                print(f"‚úÖ Type CA endpoint accessible (200)")
                
                # Test 5: V√©rifier retourne "CA - Cong√©s Annuels" depuis BDD
                ca_name = ca_type.get("name", "")
                expected_ca_name = "CA - Cong√©s Annuels"
                has_correct_ca_name = ca_name == expected_ca_name
                self.log_result("phase3", "Type CA correct depuis BDD", 
                               has_correct_ca_name,
                               f"Nom CA: '{ca_name}'" if has_correct_ca_name else f"Nom incorrect: '{ca_name}'",
                               expected_ca_name, ca_name)
                
                # Test 6: V√©rifier counting_method = "Jours Ouvrables"
                ca_counting = ca_type.get("counting_method", "")
                expected_counting = "Jours Ouvrables"
                has_correct_counting = ca_counting == expected_counting
                self.log_result("phase3", "CA counting_method correct", 
                               has_correct_counting,
                               f"Counting method: '{ca_counting}'" if has_correct_counting else f"Counting method incorrect: '{ca_counting}'",
                               expected_counting, ca_counting)
                
                print(f"\nüìã D√âTAILS TYPE CA:")
                print(f"   Code: {ca_type.get('code')}")
                print(f"   Name: {ca_type.get('name')}")
                print(f"   Category: {ca_type.get('category')}")
                print(f"   Counting Method: {ca_type.get('counting_method')}")
                print(f"   Requires Validation: {ca_type.get('requires_validation')}")
                
            else:
                self.log_result("phase3", "Type CA endpoint accessible", 
                               False, f"Erreur {response_ca.status_code}: {response_ca.text}")
                
        except Exception as e:
            self.log_result("phase3", "Absence types test", 
                           False, f"Exception: {str(e)}")

    def test_phase4_absence_creation_integration(self):
        """PHASE 4 - INT√âGRATION - CR√âATION ABSENCE"""
        print(f"\nüîÑ PHASE 4 - INT√âGRATION - CR√âATION ABSENCE")
        print("=" * 60)
        
        try:
            # Pr√©parer les donn√©es de test pour cr√©ation d'absence
            test_absence_data = {
                "employee_id": "test-employee-id",  # Sera remplac√© par l'ID admin
                "employee_name": "Diego DACALOR",
                "email": ADMIN_EMAIL,
                "date_debut": "15/01/2026",
                "jours_absence": "5",
                "motif_absence": "CA",
                "notes": "Test migration - cr√©ation absence avec type CA"
            }
            
            # R√©cup√©rer l'ID de l'utilisateur admin pour le test
            me_response = self.session.get(f"{BACKEND_URL}/auth/me")
            if me_response.status_code == 200:
                admin_user = me_response.json()
                test_absence_data["employee_id"] = admin_user.get("id")
                print(f"‚úÖ Admin user ID r√©cup√©r√©: {admin_user.get('id')}")
            
            # Test 1: POST /api/absences avec type "CA"
            response = self.session.post(f"{BACKEND_URL}/absences", json=test_absence_data)
            
            if response.status_code == 200:
                creation_response = response.json()
                absence_id = creation_response.get("id")
                print(f"‚úÖ Absence cr√©√©e avec succ√®s (200)")
                
                # R√©cup√©rer l'absence cr√©√©e depuis la base pour v√©rifier les champs enrichis
                get_response = self.session.get(f"{BACKEND_URL}/absences/{test_absence_data['employee_id']}")
                if get_response.status_code == 200:
                    absences_list = get_response.json()
                    # Trouver l'absence que nous venons de cr√©er
                    created_absence = None
                    for abs_item in absences_list:
                        if abs_item.get("id") == absence_id:
                            created_absence = abs_item
                            break
                    
                    if created_absence:
                        # Test 2: V√©rifier counting_method r√©cup√©r√© depuis BDD (via get_absence_type_config)
                        counting_method = created_absence.get("counting_method")
                        expected_counting = "Jours Ouvrables"
                        has_correct_counting = counting_method == expected_counting
                        self.log_result("phase4", "counting_method r√©cup√©r√© depuis BDD", 
                                       has_correct_counting,
                                       f"Counting method: '{counting_method}'" if has_correct_counting else f"Counting method incorrect: '{counting_method}'",
                                       expected_counting, counting_method)
                        
                        # Test 3: V√©rifier date fin calcul√©e correctement
                        date_fin = created_absence.get("date_fin")
                        has_date_fin = date_fin is not None and date_fin != "" and date_fin != "None"
                        self.log_result("phase4", "Date fin calcul√©e correctement", 
                                       has_date_fin,
                                       f"Date fin calcul√©e: {date_fin}" if has_date_fin else "Date fin manquante")
                        
                        # Test 4: V√©rifier absence cr√©√©e avec succ√®s
                        has_absence_id = absence_id is not None and absence_id != ""
                        self.log_result("phase4", "Absence cr√©√©e avec succ√®s", 
                                       has_absence_id,
                                       f"Absence ID: {absence_id}" if has_absence_id else "ID absence manquant")
                        
                        print(f"\nüìã D√âTAILS ABSENCE CR√â√âE:")
                        print(f"   ID: {created_absence.get('id')}")
                        print(f"   Employee: {created_absence.get('employee_name')}")
                        print(f"   Type: {created_absence.get('motif_absence')}")
                        print(f"   Date d√©but: {created_absence.get('date_debut')}")
                        print(f"   Date fin: {created_absence.get('date_fin')}")
                        print(f"   Jours: {created_absence.get('jours_absence')}")
                        print(f"   Counting method: {created_absence.get('counting_method')}")
                        print(f"   Status: {created_absence.get('status')}")
                    else:
                        self.log_result("phase4", "R√©cup√©ration absence cr√©√©e", 
                                       False, f"Absence {absence_id} non trouv√©e dans la liste")
                else:
                    self.log_result("phase4", "R√©cup√©ration absence cr√©√©e", 
                                   False, f"Erreur r√©cup√©ration absences: {get_response.status_code}")
                
                # Nettoyer - supprimer l'absence de test
                if absence_id:
                    delete_response = self.session.delete(f"{BACKEND_URL}/absences/{absence_id}")
                    if delete_response.status_code == 200:
                        print(f"‚úÖ Absence de test supprim√©e")
                    else:
                        print(f"‚ö†Ô∏è Impossible de supprimer l'absence de test: {delete_response.status_code}")
                
            else:
                self.log_result("phase4", "Cr√©ation absence avec type CA", 
                               False, f"Erreur {response.status_code}: {response.text}")
                
        except Exception as e:
            self.log_result("phase4", "Test cr√©ation absence", 
                           False, f"Exception: {str(e)}")

    def print_summary(self):
        """Afficher le r√©sum√© des tests"""
        print(f"\n" + "=" * 80)
        print(f"üìä R√âSUM√â COMPLET DES TESTS DE MIGRATION")
        print(f"=" * 80)
        
        total_passed = 0
        total_failed = 0
        
        for phase_name, results in self.test_results.items():
            phase_display = {
                "phase1": "PHASE 1 - SUPPRESSION FICHIERS TEST",
                "phase2": "PHASE 2 - ANALYTICS R√âELLES", 
                "phase3": "PHASE 3 - ABSENCE TYPES EN BDD",
                "phase4": "PHASE 4 - INT√âGRATION CR√âATION ABSENCE"
            }
            
            passed = results["passed"]
            failed = results["failed"]
            total = passed + failed
            
            total_passed += passed
            total_failed += failed
            
            status_icon = "‚úÖ" if failed == 0 else "‚ùå" if passed == 0 else "‚ö†Ô∏è"
            print(f"\n{status_icon} {phase_display[phase_name]}")
            print(f"   Tests r√©ussis: {passed}/{total}")
            print(f"   Tests √©chou√©s: {failed}/{total}")
            
            if failed > 0:
                print(f"   √âchecs:")
                for detail in results["details"]:
                    if "‚ùå FAIL" in detail["status"]:
                        print(f"     - {detail['test']}: {detail['message']}")
        
        print(f"\n" + "=" * 80)
        overall_status = "‚úÖ SUCC√àS COMPLET" if total_failed == 0 else "‚ùå √âCHECS D√âTECT√âS" if total_passed == 0 else "‚ö†Ô∏è SUCC√àS PARTIEL"
        print(f"üéØ R√âSULTAT GLOBAL: {overall_status}")
        print(f"üìà TOTAL: {total_passed} r√©ussis, {total_failed} √©chou√©s sur {total_passed + total_failed} tests")
        
        # Crit√®res de succ√®s selon la demande
        print(f"\nüìã CRIT√àRES DE SUCC√àS:")
        success_criteria = [
            ("Fichiers test supprim√©s", self.test_results["phase1"]["failed"] == 0),
            ("Analytics retourne donn√©es R√âELLES", self.test_results["phase2"]["failed"] == 0),
            ("22 types absence depuis MongoDB", self.test_results["phase3"]["failed"] == 0),
            ("Cr√©ation absence utilise config BDD", self.test_results["phase4"]["failed"] == 0)
        ]
        
        for criterion, met in success_criteria:
            status = "‚úÖ" if met else "‚ùå"
            print(f"   {status} {criterion}")
        
        all_success = all(met for _, met in success_criteria)
        print(f"\nüèÜ MIGRATION COMPL√àTE: {'‚úÖ R√âUSSIE' if all_success else '‚ùå INCOMPL√àTE'}")
        
        return all_success

    def run_all_tests(self):
        """Ex√©cuter tous les tests de migration"""
        print("üöÄ D√âMARRAGE DES TESTS DE MIGRATION COMPL√àTE")
        print("=" * 80)
        print("OBJECTIF: V√©rifier que toutes les modifications de la migration compl√®te (Phases 1+2+3) fonctionnent correctement")
        print("USER ACCOUNT: Admin Diego DACALOR (ddacalor@aaea-gpe.fr / admin123)")
        print("=" * 80)
        
        # Authentification
        if not self.authenticate():
            print("‚ùå Impossible de continuer sans authentification")
            return False
        
        # Ex√©cuter tous les tests
        self.test_phase1_file_deletion()
        self.test_phase2_real_analytics()
        self.test_phase3_absence_types_db()
        self.test_phase4_absence_creation_integration()
        
        # Afficher le r√©sum√©
        return self.print_summary()

def main():
    """Point d'entr√©e principal"""
    tester = MigrationTester()
    success = tester.run_all_tests()
    
    # Code de sortie
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()