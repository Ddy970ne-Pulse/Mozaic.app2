#!/usr/bin/env python3
"""
COMPREHENSIVE SECURITY ENHANCEMENTS TESTING - OPTION A: S√âCURIT√â CRITIQUE

OBJECTIF: Test complet des am√©liorations de s√©curit√© critiques impl√©ment√©es dans MOZAIK RH
USER ACCOUNT: Admin Diego DACALOR (ddacalor@aaea-gpe.fr / admin123)

PHASES DE S√âCURIT√â √Ä TESTER:
PHASE 1: SECRET_KEY Validation ‚úÖ (Backend refuse de d√©marrer sans SECRET_KEY s√©curis√©)
PHASE 2: Strict Pydantic Validation (TO TEST)
PHASE 3: Rate Limiting (TO TEST)

TESTS CRITIQUES:
1. Rate limiting on login endpoint (CRITICAL - prevents brute force)
2. Password validation (CRITICAL - security)  
3. Rate limiting on absence/user creation
4. Email validation
5. Input sanitization (length limits, patterns)

EXPECTED OUTCOMES:
- All validation rules properly enforced
- Clear error messages for validation failures
- Rate limits applied correctly with 429 responses
- Rate limit headers present in responses
- No security bypasses possible
"""

import requests
import json
import sys
import os
import asyncio
import websockets
import threading
import time
from datetime import datetime, timedelta

# Configuration
BACKEND_URL = "https://saas-hr-hub.preview.emergentagent.com/api"
WEBSOCKET_URL = "wss://hr-multi-saas.preview.emergentagent.com/api/ws"
ADMIN_EMAIL = "ddacalor@aaea-gpe.fr"
ADMIN_PASSWORD = "admin123"

class WebSocketAbsenceTester:
    def __init__(self):
        self.token = None
        self.user_id = None
        self.session = requests.Session()
        self.websocket_messages = []
        self.websocket_connected = False
        self.test_results = {
            "websocket": {"passed": 0, "failed": 0, "details": []},
            "absence_api": {"passed": 0, "failed": 0, "details": []},
            "users_api": {"passed": 0, "failed": 0, "details": []},
            "existing_apis": {"passed": 0, "failed": 0, "details": []}
        }
        
    def log_result(self, phase, test_name, success, message, expected=None, actual=None):
        """Log test result"""
        status = "‚úÖ PASS" if success else "‚ùå FAIL"
        detail = {
            "test": test_name,
            "status": status,
            "message": message
        }
        if expected is not None:
            detail["expected"] = expected
        if actual is not None:
            detail["actual"] = actual
            
        self.test_results[phase]["details"].append(detail)
        if success:
            self.test_results[phase]["passed"] += 1
        else:
            self.test_results[phase]["failed"] += 1
            
        print(f"{status} {test_name}: {message}")
        if expected is not None and actual is not None:
            print(f"    Expected: {expected}")
            print(f"    Actual: {actual}")

    def authenticate(self):
        """Authenticate as admin Diego DACALOR"""
        print(f"\nüîê AUTHENTICATION - Admin Diego DACALOR")
        print("=" * 60)
        
        try:
            response = self.session.post(f"{BACKEND_URL}/auth/login", json={
                "email": ADMIN_EMAIL,
                "password": ADMIN_PASSWORD
            })
            
            if response.status_code == 200:
                data = response.json()
                self.token = data.get("token")
                user = data.get("user", {})
                self.user_id = user.get("id")
                print(f"‚úÖ Login successful: {user.get('name')} ({user.get('email')})")
                print(f"‚úÖ Role: {user.get('role')}")
                print(f"‚úÖ User ID: {self.user_id}")
                print(f"‚úÖ Token obtained: {self.token[:20]}...")
                
                # Set authorization header for all future requests
                self.session.headers.update({"Authorization": f"Bearer {self.token}"})
                return True
            else:
                print(f"‚ùå Login failed: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            print(f"‚ùå Authentication error: {str(e)}")
            return False

    async def test_websocket_connection(self):
        """TEST 1: WebSocket Connection"""
        print(f"\nüîå TEST 1 - WEBSOCKET CONNECTION")
        print("=" * 60)
        
        if not self.user_id:
            self.log_result("websocket", "WebSocket Connection", False, "User ID manquant pour test WebSocket")
            return
        
        websocket_url = f"{WEBSOCKET_URL}/{self.user_id}"
        print(f"üîó URL WebSocket: {websocket_url}")
        
        try:
            # Test de connexion WebSocket
            async with websockets.connect(websocket_url) as websocket:
                self.websocket_connected = True
                print(f"‚úÖ Connexion WebSocket √©tablie")
                
                # Attendre un message de bienvenue
                try:
                    welcome_message = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                    print(f"‚úÖ Message de bienvenue re√ßu: {welcome_message}")
                    self.log_result("websocket", "Connexion WebSocket accept√©e", True, 
                                   f"Connexion r√©ussie sur {websocket_url}")
                    self.log_result("websocket", "Message de bienvenue re√ßu", True, 
                                   f"Message: {welcome_message}")
                except asyncio.TimeoutError:
                    print(f"‚ö†Ô∏è Aucun message de bienvenue re√ßu dans les 5 secondes")
                    self.log_result("websocket", "Message de bienvenue re√ßu", False, 
                                   "Timeout - aucun message de bienvenue")
                
                # Tester l'envoi d'un message
                test_message = {"type": "ping", "data": "test"}
                await websocket.send(json.dumps(test_message))
                print(f"‚úÖ Message de test envoy√©")
                
                # Attendre une r√©ponse
                try:
                    response = await asyncio.wait_for(websocket.recv(), timeout=3.0)
                    print(f"‚úÖ R√©ponse re√ßue: {response}")
                    self.log_result("websocket", "Communication bidirectionnelle", True, 
                                   f"R√©ponse: {response}")
                except asyncio.TimeoutError:
                    print(f"‚ö†Ô∏è Aucune r√©ponse au message de test")
                    self.log_result("websocket", "Communication bidirectionnelle", False, 
                                   "Timeout - aucune r√©ponse")
                
        except websockets.exceptions.InvalidStatusCode as e:
            if e.status_code == 404:
                self.log_result("websocket", "Connexion WebSocket accept√©e", False, 
                               f"Erreur 404 - Endpoint WebSocket non trouv√©: {websocket_url}")
            else:
                self.log_result("websocket", "Connexion WebSocket accept√©e", False, 
                               f"Erreur HTTP {e.status_code}: {str(e)}")
        except Exception as e:
            self.log_result("websocket", "Connexion WebSocket accept√©e", False, 
                           f"Erreur de connexion: {str(e)}")
    
    def run_websocket_test(self):
        """Wrapper pour ex√©cuter le test WebSocket de mani√®re synchrone"""
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(self.test_websocket_connection())
        except Exception as e:
            self.log_result("websocket", "Test WebSocket", False, f"Erreur d'ex√©cution: {str(e)}")
        finally:
            loop.close()

    def test_users_api_email_field(self):
        """TEST 3: GET /api/users - V√©rifier champ email non undefined"""
        print(f"\nüë• TEST 3 - GET /api/users - V√âRIFICATION CHAMP EMAIL")
        print("=" * 60)
        
        try:
            # Test 1: GET /api/users
            response = self.session.get(f"{BACKEND_URL}/users")
            
            if response.status_code == 200:
                users = response.json()
                print(f"‚úÖ GET /api/users accessible (200)")
                print(f"‚úÖ Nombre d'utilisateurs: {len(users)}")
                
                # Test 2: V√©rifier que chaque user a un champ email (pas undefined)
                users_with_email = 0
                users_without_email = 0
                invalid_emails = []
                
                for user in users:
                    email = user.get("email")
                    if email and email != "undefined" and email.strip():
                        users_with_email += 1
                        # V√©rifier format email basique
                        if "@" not in email or "." not in email:
                            invalid_emails.append(f"{user.get('name', 'Unknown')} - {email}")
                    else:
                        users_without_email += 1
                        invalid_emails.append(f"{user.get('name', 'Unknown')} - {email}")
                
                # R√©sultats
                all_have_valid_email = users_without_email == 0
                self.log_result("users_api", "Tous les users ont un champ email", 
                               all_have_valid_email,
                               f"{users_with_email} users avec email valide, {users_without_email} sans email" if all_have_valid_email else f"PROBL√àME: {users_without_email} users sans email valide")
                
                # Test 3: V√©rifier format email valide
                has_valid_format = len(invalid_emails) == 0
                self.log_result("users_api", "Format email valide", 
                               has_valid_format,
                               "Tous les emails ont un format valide" if has_valid_format else f"Emails invalides: {invalid_emails[:3]}")
                
                # Afficher quelques exemples
                print(f"\nüìã EXEMPLES D'UTILISATEURS:")
                for i, user in enumerate(users[:5]):
                    email = user.get("email", "MANQUANT")
                    name = user.get("name", "Unknown")
                    print(f"   {i+1}. {name} - {email}")
                
                if len(users) > 5:
                    print(f"   ... et {len(users) - 5} autres utilisateurs")
                
                if invalid_emails:
                    print(f"\n‚ö†Ô∏è EMAILS PROBL√âMATIQUES:")
                    for invalid in invalid_emails[:5]:
                        print(f"   - {invalid}")
                
            else:
                self.log_result("users_api", "GET /api/users accessible", 
                               False, f"Erreur {response.status_code}: {response.text}")
                
        except Exception as e:
            self.log_result("users_api", "Test GET /api/users", 
                           False, f"Exception: {str(e)}")

    def test_absence_api_quick_add(self):
        """TEST 2: API Absences (Ajout Rapide) - POST /api/absences"""
        print(f"\nüìù TEST 2 - API ABSENCES (AJOUT RAPIDE)")
        print("=" * 60)
        
        try:
            # √âtape a) Login d√©j√† fait dans authenticate()
            print(f"‚úÖ a) Login admin r√©ussi")
            
            # √âtape b) GET /api/users pour r√©cup√©rer un employ√©
            users_response = self.session.get(f"{BACKEND_URL}/users")
            
            if users_response.status_code != 200:
                self.log_result("absence_api", "GET /api/users pour r√©cup√©rer employ√©", 
                               False, f"Erreur {users_response.status_code}: {users_response.text}")
                return
            
            users = users_response.json()
            print(f"‚úÖ b) GET /api/users r√©ussi - {len(users)} utilisateurs trouv√©s")
            
            # Trouver un employ√© avec un email valide
            target_employee = None
            for user in users:
                email = user.get("email")
                if email and email != "undefined" and "@" in email and user.get("id"):
                    target_employee = user
                    break
            
            if not target_employee:
                self.log_result("absence_api", "Employ√© avec email valide trouv√©", 
                               False, "Aucun employ√© avec email valide trouv√©")
                return
            
            employee_id = target_employee.get("id")
            employee_name = target_employee.get("name")
            employee_email = target_employee.get("email")
            
            print(f"‚úÖ Employ√© s√©lectionn√©: {employee_name} ({employee_email})")
            self.log_result("absence_api", "Employ√© avec email valide trouv√©", 
                           True, f"Employ√©: {employee_name} - Email: {employee_email}")
            
            # √âtape c) POST /api/absences avec les donn√©es sp√©cifi√©es
            absence_data = {
                "employee_id": employee_id,
                "employee_name": employee_name,
                "email": employee_email,
                "motif_absence": "CA",
                "jours_absence": "2",
                "date_debut": "2025-11-05",
                "date_fin": "2025-11-06",
                "notes": "Test ajout rapide automatis√©",
                "status": "approved",
                "created_by": "admin"
            }
            
            print(f"üì§ c) Envoi POST /api/absences...")
            print(f"   Donn√©es: {json.dumps(absence_data, indent=2)}")
            
            absence_response = self.session.post(f"{BACKEND_URL}/absences", json=absence_data)
            
            # √âtape d) V√©rifier r√©ponse 200 OK (pas 422)
            if absence_response.status_code == 200:
                absence_result = absence_response.json()
                absence_id = absence_result.get("id")
                print(f"‚úÖ d) POST /api/absences r√©ussi (200 OK)")
                print(f"‚úÖ Absence cr√©√©e avec ID: {absence_id}")
                
                self.log_result("absence_api", "POST /api/absences r√©ponse 200 OK", 
                               True, f"Absence cr√©√©e avec succ√®s - ID: {absence_id}")
                
                # √âtape e) V√©rifier que l'absence est bien cr√©√©e
                # R√©cup√©rer les absences de l'employ√© pour v√©rifier
                get_absences_response = self.session.get(f"{BACKEND_URL}/absences/{employee_id}")
                
                if get_absences_response.status_code == 200:
                    employee_absences = get_absences_response.json()
                    
                    # Chercher l'absence que nous venons de cr√©er
                    created_absence = None
                    for absence in employee_absences:
                        if absence.get("id") == absence_id:
                            created_absence = absence
                            break
                    
                    if created_absence:
                        print(f"‚úÖ e) Absence bien cr√©√©e et r√©cup√©rable")
                        self.log_result("absence_api", "Absence bien cr√©√©e en base", 
                                       True, f"Absence trouv√©e avec motif: {created_absence.get('motif_absence')}")
                        
                        # Afficher les d√©tails de l'absence cr√©√©e
                        print(f"\nüìã D√âTAILS ABSENCE CR√â√âE:")
                        print(f"   ID: {created_absence.get('id')}")
                        print(f"   Employ√©: {created_absence.get('employee_name')}")
                        print(f"   Email: {created_absence.get('email')}")
                        print(f"   Motif: {created_absence.get('motif_absence')}")
                        print(f"   Jours: {created_absence.get('jours_absence')}")
                        print(f"   Date d√©but: {created_absence.get('date_debut')}")
                        print(f"   Date fin: {created_absence.get('date_fin')}")
                        print(f"   Status: {created_absence.get('status')}")
                        print(f"   Notes: {created_absence.get('notes')}")
                        
                        # Nettoyer - supprimer l'absence de test
                        delete_response = self.session.delete(f"{BACKEND_URL}/absences/{absence_id}")
                        if delete_response.status_code == 200:
                            print(f"‚úÖ Absence de test supprim√©e")
                        else:
                            print(f"‚ö†Ô∏è Impossible de supprimer l'absence de test: {delete_response.status_code}")
                    else:
                        self.log_result("absence_api", "Absence bien cr√©√©e en base", 
                                       False, f"Absence {absence_id} non trouv√©e dans les absences de l'employ√©")
                else:
                    self.log_result("absence_api", "V√©rification absence cr√©√©e", 
                                   False, f"Erreur r√©cup√©ration absences: {get_absences_response.status_code}")
                
            elif absence_response.status_code == 422:
                error_detail = absence_response.json()
                self.log_result("absence_api", "POST /api/absences r√©ponse 200 OK", 
                               False, f"Erreur 422 (validation): {error_detail}")
                print(f"‚ùå d) Erreur 422 - Probl√®me de validation:")
                print(f"   {json.dumps(error_detail, indent=2)}")
            else:
                self.log_result("absence_api", "POST /api/absences r√©ponse 200 OK", 
                               False, f"Erreur {absence_response.status_code}: {absence_response.text}")
                print(f"‚ùå d) Erreur {absence_response.status_code}: {absence_response.text}")
                
        except Exception as e:
            self.log_result("absence_api", "Test API Absences", 
                           False, f"Exception: {str(e)}")

    def test_existing_endpoints(self):
        """TEST 4: Tests Existants - Valider endpoints existants"""
        print(f"\nüîß TEST 4 - ENDPOINTS EXISTANTS")
        print("=" * 60)
        
        endpoints_to_test = [
            ("GET /api/users", f"{BACKEND_URL}/users"),
            ("GET /api/absences", f"{BACKEND_URL}/absences"),
            ("POST /api/auth/login", f"{BACKEND_URL}/auth/login"),
        ]
        
        for endpoint_name, url in endpoints_to_test:
            try:
                if "login" in endpoint_name:
                    # Test sp√©cial pour login
                    response = requests.post(url, json={
                        "email": ADMIN_EMAIL,
                        "password": ADMIN_PASSWORD
                    })
                else:
                    # Test GET normal avec authentification
                    response = self.session.get(url)
                
                if response.status_code == 200:
                    print(f"‚úÖ {endpoint_name} - OK (200)")
                    self.log_result("existing_apis", f"{endpoint_name} fonctionnel", 
                                   True, f"R√©ponse 200 OK")
                else:
                    print(f"‚ùå {endpoint_name} - Erreur {response.status_code}")
                    self.log_result("existing_apis", f"{endpoint_name} fonctionnel", 
                                   False, f"Erreur {response.status_code}: {response.text[:100]}")
                    
            except Exception as e:
                print(f"‚ùå {endpoint_name} - Exception: {str(e)}")
                self.log_result("existing_apis", f"{endpoint_name} fonctionnel", 
                               False, f"Exception: {str(e)}")
        
        # Test sp√©cial pour PUT /api/absences/{id} (approve/reject)
        try:
            # D'abord cr√©er une absence de test
            test_absence = {
                "employee_id": self.user_id,
                "employee_name": "Diego DACALOR",
                "email": ADMIN_EMAIL,
                "motif_absence": "CA",
                "jours_absence": "1",
                "date_debut": "2025-12-01",
                "notes": "Test PUT endpoint",
                "status": "pending"
            }
            
            create_response = self.session.post(f"{BACKEND_URL}/absences", json=test_absence)
            
            if create_response.status_code == 200:
                absence_id = create_response.json().get("id")
                
                # Tester PUT approve
                put_response = self.session.put(f"{BACKEND_URL}/absences/{absence_id}", json={
                    "status": "approved"
                })
                
                if put_response.status_code == 200:
                    print(f"‚úÖ PUT /api/absences/{absence_id} (approve) - OK (200)")
                    self.log_result("existing_apis", "PUT /api/absences/{id} (approve) fonctionnel", 
                                   True, "Approbation r√©ussie")
                else:
                    print(f"‚ùå PUT /api/absences/{absence_id} (approve) - Erreur {put_response.status_code}")
                    self.log_result("existing_apis", "PUT /api/absences/{id} (approve) fonctionnel", 
                                   False, f"Erreur {put_response.status_code}")
                
                # Nettoyer
                self.session.delete(f"{BACKEND_URL}/absences/{absence_id}")
            else:
                self.log_result("existing_apis", "PUT /api/absences/{id} test setup", 
                               False, "Impossible de cr√©er absence de test pour PUT")
                
        except Exception as e:
            self.log_result("existing_apis", "PUT /api/absences/{id} fonctionnel", 
                           False, f"Exception: {str(e)}")

    def print_summary(self):
        """Afficher le r√©sum√© des tests"""
        print(f"\n" + "=" * 80)
        print(f"üìä R√âSUM√â COMPLET DES TESTS WEBSOCKET & ABSENCE")
        print(f"=" * 80)
        
        total_passed = 0
        total_failed = 0
        
        for phase_name, results in self.test_results.items():
            phase_display = {
                "websocket": "TEST 1 - WEBSOCKET CONNECTION",
                "absence_api": "TEST 2 - API ABSENCES (AJOUT RAPIDE)", 
                "users_api": "TEST 3 - GET /api/users (EMAIL FIELD)",
                "existing_apis": "TEST 4 - ENDPOINTS EXISTANTS"
            }
            
            passed = results["passed"]
            failed = results["failed"]
            total = passed + failed
            
            total_passed += passed
            total_failed += failed
            
            status_icon = "‚úÖ" if failed == 0 else "‚ùå" if passed == 0 else "‚ö†Ô∏è"
            print(f"\n{status_icon} {phase_display[phase_name]}")
            print(f"   Tests r√©ussis: {passed}/{total}")
            print(f"   Tests √©chou√©s: {failed}/{total}")
            
            if failed > 0:
                print(f"   √âchecs:")
                for detail in results["details"]:
                    if "‚ùå FAIL" in detail["status"]:
                        print(f"     - {detail['test']}: {detail['message']}")
        
        print(f"\n" + "=" * 80)
        overall_status = "‚úÖ SUCC√àS COMPLET" if total_failed == 0 else "‚ùå √âCHECS D√âTECT√âS" if total_passed == 0 else "‚ö†Ô∏è SUCC√àS PARTIEL"
        print(f"üéØ R√âSULTAT GLOBAL: {overall_status}")
        print(f"üìà TOTAL: {total_passed} r√©ussis, {total_failed} √©chou√©s sur {total_passed + total_failed} tests")
        
        # Crit√®res de succ√®s selon la demande fran√ßaise
        print(f"\nüìã CRIT√àRES DE SUCC√àS:")
        success_criteria = [
            ("WebSocket connexion accept√©e (pas 404)", self.test_results["websocket"]["failed"] == 0),
            ("Message de bienvenue WebSocket re√ßu", self.test_results["websocket"]["passed"] >= 1),
            ("POST /api/absences r√©ponse 200 OK (pas 422)", self.test_results["absence_api"]["failed"] == 0),
            ("Absence bien cr√©√©e en base", self.test_results["absence_api"]["passed"] >= 2),
            ("Tous les users ont champ email valide", self.test_results["users_api"]["failed"] == 0),
            ("Endpoints existants fonctionnels", self.test_results["existing_apis"]["failed"] == 0)
        ]
        
        for criterion, met in success_criteria:
            status = "‚úÖ" if met else "‚ùå"
            print(f"   {status} {criterion}")
        
        # Focus sur tests 2 et 3 comme demand√©
        print(f"\nüéØ PRIORIT√â TESTS 2 & 3 (bug email r√©solu?):")
        test2_success = self.test_results["absence_api"]["failed"] == 0
        test3_success = self.test_results["users_api"]["failed"] == 0
        print(f"   {'‚úÖ' if test2_success else '‚ùå'} TEST 2 - API Absences (Ajout Rapide)")
        print(f"   {'‚úÖ' if test3_success else '‚ùå'} TEST 3 - GET /api/users (Email Field)")
        
        priority_success = test2_success and test3_success
        print(f"\nüèÜ TESTS PRIORITAIRES: {'‚úÖ R√âUSSIS' if priority_success else '‚ùå √âCHECS D√âTECT√âS'}")
        
        return priority_success

    def run_all_tests(self):
        """Ex√©cuter tous les tests WebSocket et Absence"""
        print("üöÄ D√âMARRAGE DES TESTS WEBSOCKET & ABSENCE")
        print("=" * 80)
        print("OBJECTIF: Test complet des fonctionnalit√©s MOZAIK RH apr√®s impl√©mentation WebSocket et ajout rapide d'absence")
        print("USER ACCOUNT: Admin Diego DACALOR (ddacalor@aaea-gpe.fr / admin123)")
        print("PRIORIT√â: Focus sur tests 2 et 3 (bug email r√©solu?)")
        print("=" * 80)
        
        # Authentification
        if not self.authenticate():
            print("‚ùå Impossible de continuer sans authentification")
            return False
        
        # Ex√©cuter tous les tests
        print(f"\nüîÑ EX√âCUTION DES TESTS...")
        
        # Test 1: WebSocket Connection
        self.run_websocket_test()
        
        # Test 2: API Absences (Ajout Rapide) - PRIORIT√â
        self.test_absence_api_quick_add()
        
        # Test 3: GET /api/users (Email Field) - PRIORIT√â  
        self.test_users_api_email_field()
        
        # Test 4: Endpoints Existants
        self.test_existing_endpoints()
        
        # Afficher le r√©sum√©
        return self.print_summary()

def main():
    """Point d'entr√©e principal"""
    tester = WebSocketAbsenceTester()
    success = tester.run_all_tests()
    
    # Code de sortie
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()